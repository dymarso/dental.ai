# backend/_config/Dockerfile.development
# Multi-stage build for optimized image size
# Features: Auto-migrations, auto-restore, scheduled backups, non-root user
# ---------- Build Stage ----------
FROM python:3.12.5-slim-bookworm AS python-build-stage

WORKDIR /backend
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_NO_CACHE_DIR=off

# Copy system package requirements first
COPY backend/_config/requirements/packages.txt ./requirements/

# Install build deps from packages.txt for easy customization
# Edit requirements/packages.txt to add/remove system dependencies
RUN set -e; \
    apt-get update; \
    # Extract package names: remove full-line comments, strip inline comments, filter empty lines
    PACKAGES=$(grep -v '^#' requirements/packages.txt | \
               sed 's/#.*//' | \
               grep -v '^$' | \
               tr '\n' ' ' | \
               sed 's/  */ /g'); \
    if [ -n "$PACKAGES" ]; then \
        echo "Installing packages from packages.txt: $PACKAGES"; \
        apt-get install -y --no-install-recommends $PACKAGES; \
    else \
        echo "Warning: No uncommented packages found in packages.txt"; \
    fi; \
    rm -rf /var/lib/apt/lists/*

# Upgrade pip first for better dependency resolution
RUN pip install --no-cache-dir --upgrade pip setuptools wheel

# Copy only requirements first to leverage layer caching
COPY backend/_config/requirements/ ./requirements/
# Build wheels (faster installs in runtime stage)
# --prefer-binary avoids building from source when possible
RUN pip wheel --wheel-dir /wheels --prefer-binary -r requirements/development.txt

# ---------- Runtime Stage ----------
FROM python:3.12.5-slim-bookworm AS python-run-stage

WORKDIR /backend
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONPATH=/backend \
    PIP_NO_CACHE_DIR=1

# Minimal runtime deps with PostgreSQL client
RUN apt-get update \
 && apt-get install -y --no-install-recommends \
    libpq-dev \
    postgresql-client \
    gettext \
    curl \
    netcat-openbsd \
    cron \
    gzip \
    cpio \
    ffmpeg \
    imagemagick \
    wget \
 && rm -rf /var/lib/apt/lists/* \
 && apt-get clean

# Copy wheels and install (no network at runtime; faster)
COPY --from=python-build-stage /wheels /wheels
RUN pip install --no-cache-dir --no-index --find-links=/wheels /wheels/* \
 && rm -rf /wheels

# Create non-root user for safety
RUN addgroup --system django && adduser --system --ingroup django django

# Copy project source with ownership for the django user
COPY --chown=django:django . /backend

# Copy and setup backup scripts
# Two scripts: backup.sh (basic) and backup_gcs.sh (with GCS support)
COPY --chown=django:django backend/_config/backup/backup.sh /backend/_config/backup/backup.sh
COPY --chown=django:django backend/_config/backup/backup_gcs.sh /backend/_config/backup/backup_gcs.sh
RUN chmod +x /backend/_config/backup/backup.sh /backend/_config/backup/backup_gcs.sh && \
    mkdir -p /backend/_config/backup/start /backend/_config/backup/db /backend/_config/backup/snapshots && \
    chown -R django:django /backend/_config/backup

# Setup cron for daily database backups at 2:00 AM
RUN echo "0 2 * * * /backend/_config/backup/backup.sh db >> /backend/_config/backup/backup.log 2>&1" | crontab -u django -

# Ensure django user has write permissions to the backend directory
RUN chown -R django:django /backend && \
    chmod -R 755 /backend && \
    mkdir -p /backend/media && \
    chown -R django:django /backend/media && \
    chmod -R 755 /backend/media

# Set environment variables with defaults
ENV DB_HOST=db \
    DB_PORT=5432 \
    DB_NAME=postgres \
    DB_USER=postgres \
    DB_PASSWORD=postgres \
    DJANGO_SETTINGS_MODULE=_config.settings \
    MAX_WAIT=60 \
    SLEEP=2 \
    WAITED=0

# Create entrypoint script
RUN cat > /entrypoint.sh <<'EOF'
#!/bin/sh
set -e

echo "ğŸš€ Starting Django dev container"

# Start cron daemon for scheduled backups
echo "ğŸ“… Starting cron daemon..."
cron

# Wait for DB with hardcoded credentials
echo "â³ Waiting for database at $DB_HOST:$DB_PORT..."
while [ $WAITED -lt $MAX_WAIT ]; do
    # Test basic connectivity first
    if nc -z -w 1 "$DB_HOST" "$DB_PORT" 2>/dev/null; then
        # Test authentication with actual PostgreSQL connection
        if PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "SELECT 1;" >/dev/null 2>&1; then
            echo "âœ… Database is reachable and authentication successful"
            break
        else
            echo "âš ï¸ Database reachable but authentication failed - checking if it's initializing..."
        fi
    fi

    echo "â° Waiting for database... ($((WAITED + SLEEP))s/${MAX_WAIT}s)"
    sleep $SLEEP
    WAITED=$((WAITED + SLEEP))
done

if [ $WAITED -ge $MAX_WAIT ]; then
    echo "âŒ Timeout waiting for DB ($DB_HOST:$DB_PORT) with successful authentication"
    echo "   Check if database container is running and credentials match"
    exit 1
fi

# Restore from start folder if any .sql files exist
echo "ğŸ”„ Checking for database restore..."
if [ -f /backend/_config/backup/backup.sh ]; then
    /backend/_config/backup/backup.sh auto-restore || echo "âš ï¸ Restore skipped or failed, continuing..."
fi

# Auto-restore from start directory (backup files)
echo "ğŸ”„ Checking for backups in start directory..."
if [ -f /backend/_config/backup/backup.sh ]; then
    /backend/_config/backup/backup.sh auto-restore || echo "âš ï¸ No backup files found, continuing..."
fi

# Create migration directories for all apps with models
echo "ğŸ“ Ensuring migrations directories exist..."
find /backend -name "models.py" -type f | while read -r models_file; do
    app_dir=$(dirname "$models_file")
    migrations_dir="$app_dir/migrations"
    if [ ! -d "$migrations_dir" ]; then
        echo "ğŸ“‚ Creating $migrations_dir"
        mkdir -p "$migrations_dir"
        echo "# Created by Docker entrypoint" > "$migrations_dir/__init__.py"
    fi
done

# Auto-generate migrations only for apps that need it
if [ "${AUTO_MAKEMIGRATIONS:-true}" = "true" ]; then
    echo "ğŸ› ï¸ Checking for migration changes..."
    # Check if there are model changes without migrations
    if python manage.py makemigrations --dry-run --noinput 2>/dev/null | grep -q "No changes detected"; then
        echo "âœ… No migration changes needed"
    else
        echo "ğŸ“ Generating migrations..."
        if ! python manage.py makemigrations --noinput; then
            echo "âš ï¸ Migration generation failed, but continuing..."
            echo "   This may cause issues if there are unapplied model changes."
        fi
    fi
fi

# Run migrations - MUST succeed for the app to work properly
if [ -f manage.py ]; then
    echo "ğŸ“¦ Applying migrations..."
    if ! python manage.py migrate --noinput; then
        echo "âŒ Migration failed! This is a fatal error."
        echo "   Database tables are required for the application to work."
        echo "   Please check the database connection and migration files."
        exit 1
    fi
    echo "âœ… Migrations applied successfully"

    echo "ğŸ“ Collecting static files..."
    python manage.py collectstatic --noinput --clear || echo "âš ï¸ Static collection failed, continuing..."
fi

# Create superuser with proper error handling
if [ -n "$DJANGO_SUPERUSER_USERNAME" ]; then
    echo "ğŸ‘¤ Ensuring superuser exists..."
    python - <<PY
import os
import django
import sys

os.environ.setdefault('DJANGO_SETTINGS_MODULE', os.getenv('DJANGO_SETTINGS_MODULE', '_config.settings'))

try:
    django.setup()
except django.core.exceptions.ImproperlyConfigured as e:
    print(f"âŒ Django not properly configured: {e}")
    sys.exit(1)
except Exception as e:
    print(f"âŒ Error setting up Django: {e}")
    sys.exit(1)

from django.contrib.auth import get_user_model
from django.db import DatabaseError, OperationalError

User = get_user_model()
username = os.getenv('DJANGO_SUPERUSER_USERNAME')
domain = os.getenv('DOMAIN')
email = os.getenv('DJANGO_SUPERUSER_EMAIL', f'{username}@{domain}')
password = os.getenv('DJANGO_SUPERUSER_PASSWORD')

try:
    if username and not User.objects.filter(username=username).exists():
        User.objects.create_superuser(username, email, password)
        print(f"âœ… Created superuser: {username} with email: {email}")
    elif User.objects.filter(username=username).exists():
        print(f"â„¹ï¸ Superuser already exists: {username}")
    else:
        print("âš ï¸ Superuser username not provided")
except DatabaseError as e:
    print(f"âŒ Database error creating superuser: {e}")
except OperationalError as e:
    print(f"âŒ Database operational error: {e}")
except Exception as e:
    print(f"âŒ Unexpected error creating superuser: {e}")
PY
fi

echo "ğŸ¯ Development environment ready!"

# If running as root, switch to django user for the main command
if [ "$(id -u)" -eq 0 ]; then
    # Use su with -s to specify shell and avoid home directory issues
    # The django user has /nonexistent as home, so we don't use login (-) flag
    exec su -s /bin/sh django -c "cd /backend && exec \"\$0\" \"\$@\"" -- "$@"
else
    exec "$@"
fi
EOF

RUN chmod +x /entrypoint.sh

# Keep container running as root so cron can start, but switch to django for app
ENTRYPOINT ["/entrypoint.sh"]
CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]